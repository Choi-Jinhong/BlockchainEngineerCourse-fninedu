# 2020_05_28 (Day_4)

## string
_String_변수_.startWith("글자"): 글자로 시작하는 String변수인지를 확인 => true, false로 반환
_String_변수_.charAt(index): 해당 변수의 index번째 글자를 반환

## 중첩 for
loop:for( ; ; ){
        for( ; ; ){
            if()                     =====================>>> loop로 지정된 부분까지 벗어나는 것이 가능하다.
                break loop;
        }
}

# 2020_05_29 (Day_5)
: 배열을 이용한 반복문을 할 예정
- 1차원 배열만 할 줄 알면 왠만큼 할 수 있음
##
#### 조퇴로 인해 업로드 지연
#### 정보 처리 기사 시험 이후 업데이트 예정

# 2020_06_01 (DAY_6)
: 클래스에 관한 내용을 진행

## 클래스의 3가지 구성요소
##### - 인스턴스 변수: 데이터가 실제 저장되는 곳
##### - 메소드: 인스턴스 변수에 저장된 속성값을 수정하거나 조회하는 역할
##### - 생성자: 인스턴스 변수를 초기화하는 역할, 변수에 데이터를 제일 처음 저장할 때 사용

## 생성자(Constructor)
#### : 객체 생성 시 자동 호출되는 메소드

### 형식
#### 접근지정자 메소드명()

### 특징
##### 1. 일반 메소드하고 차이점: 리턴형이 없다.
##### 2. 메소드 명은 반드시 클래스와 같아야 한다.(대소문자 동일)
##### 3. Overloading이 가능하다. -> 여러 개의 생성자를 만들 수 있다.
##### 4. 생성자가 없을 경우 기본 생성자로 생성이 가능하다.
##### 5. 생성자에서는 주로 멤버의 초기화를 담당한다.
##### 6. 같은 생성자끼리 호출은 "this()" -> this는 첫 줄?
##### 7. 생성자가 따로 지정될 경우 Default 생성자는 사라지게 되며, 필요한 경우에는 따로 생성해주어야 한다.

### 예제
##### CardTest_01.java: 인스턴스 변수와 클래스 변수에 대한 설명
##### Counter_02.java: static 변수의 사용에 따른 결과값 변화
##### TestA_03.java, ObTestA_03.java: 클래스 변수와 인스턴스 변수의 호출의 차이
##### ConstTest_04.java: 생성자와 메소드의 사용
##### ConstTest_05.java: 생성자와 메소드 사용 실습
##### ConstOver_06.java: Overloading의 사용 
##### ConstThis_07.java: this를 이용한 생성자 활용

## 접근지정자
### pritvate
##### : 해당 클래스가 가진 멤버 메소드만 접근 가능 -> 변수를 캡슐화 한 것
### protected
##### : 패키지가 다를 경우 상속받은 클래스만 접근 가능
### default(아무것도 안 쓴 경우)
##### : 패키지가 다를 경우 접근 불가
### public
##### : 패키지 상관없이 어디서든 접근 가능
### 예제
##### Student_08.java, StudentTest_08: private로 만들어진 인스턴스 변수를 변경하는 getter, setter
##### MyDateTest_09: Alt+Insert를 이용해 getter, setter 자동 생성

## Method
### 예제
##### MethodTest_10, MethodTest_11: Method 생성 연습
##### MethodReturn_12: return을 통해 결과값 반환
##### MehtodReturn_13: return을 사용하여 메소드를 벗어나는 방법
##### PersonTest_14: 생성자 실습
##### InfoData_15, InfoDataTest_15: 메소드 실습
##### Sangpum_16, SangpumTest_16: 메소드 실습
##### ScoreTest_17: 생성자, 메소드 실습

# 2020_06_02 (DAY_7)
##### FoodTest_00: 생성자 메소드 복습
##### ArratyConst_01, ArrayConst_02: 배열을 이용하여 생성자 활용
##### InstTest_03, Day_0602_1/InstConst_03: 외부 패키지의 메소드 활용
## 자바의 상속
### [is a 관계]
중복, 공통점을 추출해서 상위개념의 객체로 만들 수 있으며 상위개념의 객체를 상속받아 사용한다면 중복이 제거되고 재사용성도 향상 
즉, is a 관계는 자바의 상속기법을 적용
부모 클래스가 다른 패키지에 있을 경우 protected ,public 변수는 접근이 가능하다
같은 패키지인 경우에는 private 만 빼고 모두 접근 가능

### [상속의 조건]
##### 1. 객체간 is a 관계
##### 2. 같은패키지에선 부모클래스의 멤버(인스턴스변수,메소드)를 자식클래스가 선언없이사용가능하다(단,private 접근지정자 제외)-다른패키지에선 import해야함
##### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - private: 같은 패키지여도 상속 못 받음
##### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - default: 패키지가 다르면 상속받을 수 없다
##### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - protected: 패키지가 달라도 상속받을수 있다.상속받은 클래스만 사용가능

##### 3. 자바는 단일 상속만 지원
##### 4. 상속은 extends키워드로 표현
##### 5. 가장상위는 java.lang.Object. 따라서 모든 클래스는 Object클래스를 상속

클래스를 객체생성할때는 자동으로 부모->자식순이다
그래야 자식이 부모의멤버를사용할수있기때문이다.
이때 부모클래스를 객체생성시키기 위해 자동으로 부모 생성자가 호출되며 자동호출되는생성자는 인자가 없는 디폴트 생성자이다
따라서 반드시 부모클래스에는 디폴트 생성자가 없으면 에러가 발생한다


#### [오버라이딩]
하위클래스에서 부모클래스의 메소드를 수정해서 사용하는 것
1. 상속이 전제  
2. 메소드이름이 동일  
3. 메소드리턴타입이 동일
4. 접근지정자는 확대만 가능   
5. 예외클래스는 축소만 가능
6. static,final,private지정자를 가진 메소드는오버라이딩 불가능

### [추상클래스(abstract)]
##### - abstract 클래스는 new로 생성못함
##### - abstract 메소드는 abstract 클래스에서만 존재할 수 잇음
##### - abstract 클래스는 일반메소드와 추상메소드 둘 다 포함 가능 -> 추상메소드가 하나라도 있으면 추상 클래스
##### - 추상클래스의 목적은 overriding이다 !!

### [인터페이스(interface)]
##### - 추상메소드만 포함되어 있는 클래스
##### - 내용이 구성되있지 않아 implements를 통해 내용을 구성

### [extends와 implements구분]
##### - 클래스가 클래스를 extends
##### - 클래스가 인터페이스를 implements
##### - 인터페이스가 인터페이스를 extends

### [다형성]
#### (부모클래스명) (변수명) = new (자식클래스명)();
##### 다형성은 하나의 변수로 여러가지 일을 처리할 때 이용
##### 다형성은 하위클래스로 생성

# 2020_06_03 (DAY_8)
### [내부클래스]
##### - 특정클래스 내에 또 다른 클래스가 정의됨
##### - 하나의 멤버처럼 사용할 수 있음(외부 클래스의 모든 멤버들을 마치 자신의 멤버처럼 사용할 수 있음)
##### - 클래스당 한개씩만 상속받는 단점을 어느정도 보안해줌

### [익명 내부 클래스]
#### Anonymous Inner Class
##### 클래스 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)
##### 이벤트 발생시 생성했다 끝나면 메모리에서 제거 -> 메모리의 효울적관리가 쉽다

### [예외(Exception)]
##### - 프로그램 진행중 예외가 발생했을 때 프로그램이 종료되지만,가벼운 예외이거나 예상하고 있던 예외인 경우 예외처리를 해주어서프로그램의 비 정상적인 종료를 막고 정상적으로 프로그램을 계속 진행할 수 있도록 해줌
##### - RuntimeException -컴파일시에는문제가없지만실행할때 문제가 발생하는 경우
##### - NullPointerExceiption - 생성하지 않고 클래스의 메소드를 호출하는 경우
##### - NumberFormatExcetpion - 입력한 데이터의 형식 오류(숫자입력시 문자가 포함된 경우)
##### - ArrayIndexOutOfBoundsException - 문자열의 인덱스에 대한 오류(특정 배열의 인덱스를 벗어난 경우?)

### [List(인터페이스)]
##### - 배열과 비슷하지만 배열은 메모리가 연속적,길이정해진 반면 List의 구조는 연속적이지 않고 중간에 추가삭제가능하고 데이터길이가 가변적이다
##### - List 안에 3개의 subclass가 존재
##### - stack
##### * Vector-순차적,중복데이터
##### * ArrayList-순차적,중복데이터

### [메소드]
##### - Get(int index)-리스트내의 지정된위치에 있는 요소를 돌려준다(지정해준 데이터형으로)
##### - toArray(): 리스트내의모든요소를 순서대로 포함하고 있는 배열에 넣어준다
##### (반환형:Object[])
##### - isEmpty(): Vector가 비었는지 않았는지(반환형:Boolean)

## 2020_06_04 (Day_9)
[제네릭]
자료형에 어떤 객체를 담을지 명시
*Generics는 컬렉션(자료구조) 즉, 쉽게 말해서 객체들을 저장(수집)하는 구조적인 성격을 보강하기 위해 제공되는 것이다.
  간단히 예를 들자면 컵이라는 특정 객체가 있다. 이 컵은 물만 담을 수 있는 물컵, 또는 이 컵은 주스만 담을 수 있는 주스 컵!
  이렇게 상징적인 것이 바로 Generics다!
  [쓰레드]
  *멀티 태스킹
  §프로세스란 운영체제에서 실행중인 하나의 프로그램을 말한다.
  §멀티 프로세스란 두 개 이상의 프로세스가 실행되는 것을 말한다.
  §멀티 태스킹이란 두 개 이상의 프로세스를 실행하여 일을 처리하는 것을 말한다.
  *멀티 스레드
  §스레드란 프로세스 내에서 실행되는 세부 작업 단위이다.
  §멀티 스레드란 하나의 프로세스에서 여러 개의 스레드가 병행적으로 처리되는 것을 말한다.
   
  Ø  자바에서 멀티스레드를 구현하는 방법은 2가지가 있다
  Ø  1번째  클래스 Thread 를 상속받는방법
  Ø  2번째  인터페이스  Runnable 을 구현하는 방법
  Ø  위의 클래스 또는 인터페이스가 가진 run 메소드를 오버라이드한다
  Ø  run 메소드 호출은 start 이다
  *스레드의 생명주기
  §스레드는 Thread 객체가 생성되면 생명주기를 갖게 되는데 크게 5가지로 나누게 된다.
  §New – 스레드가 만들어진 상태.
  §Runnable – 스레드 객체가 생성된 후에 start() 메서드를 호출하면 Runnable 상태로 이동하게 된다.
  §Running – Runnable 상태에서 스레드 스케줄러에 의해 Running 상태로 이동하게 된다.
  §Blocked – 스레드가 다른 특정한 이유로 Running 상태에서 Blocked 상태로 이동하게 된다.
  §Dead – 스레드가 종료되면 그 스레드는 다시 시작할 수 없게 된다.

